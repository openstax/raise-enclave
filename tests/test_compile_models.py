import boto3
from botocore.stub import Stubber
from enclave_mgmt import compile_models, data_collection
import io
import json
import os
import csv


def test_compile_models(
    mocker, tmp_path, local_file_collections,
    autogenerated_user_uuid, local_expected_csvs
):
    os.environ["CSV_OUTPUT_DIR"] = str(tmp_path)

    mocker.patch(
        "enclave_mgmt.data_collection.uuid4",
        lambda: autogenerated_user_uuid
    )

    (moodle_grades, moodle_users,
        quiz_questions, quiz_question_contents,
        quiz_multichoice_answers,
        ib_input_instances,
        ib_pset_problems,
        course_contents,
        content_loads,
        ib_pset_problem_attempts,
        ib_input_submissions
     ) = local_file_collections

    s3_client = boto3.client('s3')
    stubber_client = Stubber(s3_client)

    data_bucket_name = "sample_bucket"
    data_key = "data_files"
    event_data_bucket_name = "sample_event_bucket"
    event_data_key = "event_data_files"

    grade_list = {"Contents": [{"Key": "2"}]}
    user_list = {"Contents": [{"Key": "2"}]}

    grades_data = json.dumps(moodle_grades).encode('utf-8')
    grades_data_obj = {"Body": io.BytesIO(grades_data)}
    users_data = json.dumps(moodle_users).encode('utf-8')
    users_data_obj = {"Body": io.BytesIO(users_data)}

    stubber_client.add_response(
        "list_objects", grade_list,
        expected_params={
            'Bucket': data_bucket_name,
            'Prefix': f"{data_key}/moodle/grades"
        })
    stubber_client.add_response(
        'get_object', grades_data_obj,
        expected_params={
            'Bucket': data_bucket_name,
            'Key': '2'
        }
    )
    stubber_client.add_response(
        "list_objects", user_list,
        expected_params={
            'Bucket': data_bucket_name,
            'Prefix': f"{data_key}/moodle/users"
        }
    )
    stubber_client.add_response(
        'get_object', users_data_obj,
        expected_params={
            'Bucket': data_bucket_name,
            'Key': '2'
        }
    )

    body = io.BytesIO(quiz_questions.encode('utf-8'))
    stubber_client.add_response(
        'get_object', {"Body": body},
        expected_params={
            'Bucket': data_bucket_name,
            'Key': f"{data_key}/content/quiz_questions.csv"
            }
        )

    body = io.BytesIO(quiz_question_contents.encode('utf-8'))
    stubber_client.add_response(
        'get_object', {"Body": body},
        expected_params={
            'Bucket': data_bucket_name,
            'Key': f"{data_key}/content/quiz_question_contents.csv"
            }
        )

    body = io.BytesIO(quiz_multichoice_answers.encode('utf-8'))
    stubber_client.add_response(
        'get_object', {"Body": body},
        expected_params={
            'Bucket': data_bucket_name,
            'Key': f"{data_key}/content/quiz_multichoice_answers.csv"
            }
        )

    body = io.BytesIO(ib_input_instances.encode('utf-8'))
    stubber_client.add_response(
        'get_object', {"Body": body},
        expected_params={
            'Bucket': data_bucket_name,
            'Key': f"{data_key}/content/ib_input_instances.csv"
            }
        )

    body = io.BytesIO(ib_pset_problems.encode('utf-8'))
    stubber_client.add_response(
        'get_object', {"Body": body},
        expected_params={
            'Bucket': data_bucket_name,
            'Key': f"{data_key}/content/ib_pset_problems.csv"
            }
        )

    body = io.BytesIO(course_contents.encode('utf-8'))
    stubber_client.add_response(
        'get_object', {"Body": body},
        expected_params={
            'Bucket': data_bucket_name,
            'Key': f"{data_key}/content/course_contents.csv"
            }
        )

    body = io.BytesIO(content_loads.encode('utf-8'))
    stubber_client.add_response(
        'get_object', {"Body": body},
        expected_params={
            'Bucket': event_data_bucket_name,
            'Key': f"{event_data_key}/content_loaded_v1.json"
            }
        )

    body = io.BytesIO(ib_pset_problem_attempts.encode('utf-8'))
    stubber_client.add_response(
        'get_object', {"Body": body},
        expected_params={
            'Bucket': event_data_bucket_name,
            'Key': f"{event_data_key}/ib_pset_problem_attempted_v1.json"
            }
        )

    body = io.BytesIO(ib_input_submissions.encode('utf-8'))
    stubber_client.add_response(
        'get_object', {"Body": body},
        expected_params={
            'Bucket': event_data_bucket_name,
            'Key': f"{event_data_key}/ib_input_submitted_v1.json"
            }
        )

    stubber_client.activate()
    mocker.patch('boto3.client', lambda service: s3_client)

    mocker.patch(
        "sys.argv",
        ["", data_bucket_name, data_key, event_data_bucket_name,
         event_data_key]
    )
    compile_models.main()

    stubber_client.assert_no_pending_responses()

    (expected_assignments,
     expected_users,
     expected_grades,
     expected_enrollments,
     expected_courses,
     expected_quiz_questions,
     expected_quiz_question_contents,
     expected_quiz_multichoice_answers,
     expected_ib_input_instances,
     expected_ib_pset_problems,
     expected_course_contents,
     expected_quiz_attempts,
     expected_quiz_attempt_multichoice_responses,
     expected_content_loads,
     expected_ib_pset_problem_attempts,
     expected_ib_input_submissions
     ) = local_expected_csvs

    with open(tmp_path / "assessments.csv", 'r') as f:
        results = list(csv.DictReader(f))
        for i in expected_assignments:
            assert i in results

    with open(tmp_path / "users.csv", 'r') as f:
        results = list(csv.DictReader(f))
        for i in expected_users:
            assert i in results

    with open(tmp_path / "enrollments.csv", 'r') as f:
        results = list(csv.DictReader(f))
        for i in expected_enrollments:
            assert i in results

    with open(tmp_path / "courses.csv", 'r') as f:
        results = list(csv.DictReader(f))
        for i in expected_courses:
            assert i in results

    with open(tmp_path / "grades.csv", 'r') as f:
        results = list(csv.DictReader(f))
        for i in expected_grades:
            assert i in results

    with open(tmp_path / "quiz_questions.csv", 'r') as f:
        results = list(csv.DictReader(f))
        for i in expected_quiz_questions:
            assert i in results

    with open(tmp_path / "quiz_question_contents.csv", 'r') as f:
        results = list(csv.DictReader(f))
        for i in expected_quiz_question_contents:
            assert i in results

    with open(tmp_path / "quiz_multichoice_answers.csv", 'r') as f:
        results = list(csv.DictReader(f))
        for i in expected_quiz_multichoice_answers:
            assert i in results

    with open(tmp_path / "ib_input_instances.csv", 'r') as f:
        results = list(csv.DictReader(f))
        for i in expected_ib_input_instances:
            assert i in results

    with open(tmp_path / "ib_pset_problems.csv", 'r') as f:
        results = list(csv.DictReader(f))
        for i in expected_ib_pset_problems:
            assert i in results

    with open(tmp_path / "course_contents.csv", 'r') as f:
        results = list(csv.DictReader(f))
        for i in expected_course_contents:
            assert i in results

    with open(tmp_path / "quiz_attempts.csv", 'r') as f:
        results = list(csv.DictReader(f))
        for i in expected_quiz_attempts:
            assert i in results

    with open(tmp_path / "quiz_attempt_multichoice_responses.csv", 'r') as f:
        results = list(csv.DictReader(f))
        for i in expected_quiz_attempt_multichoice_responses:
            assert i in results

    with open(tmp_path / "content_loads.csv", 'r') as f:
        results = list(csv.DictReader(f))
        assert len(results) == len(expected_content_loads)

        for i in expected_content_loads:
            assert i in results

    with open(tmp_path / "ib_pset_problem_attempts.csv", 'r') as f:
        results = list(csv.DictReader(f))
        assert len(results) == len(expected_ib_pset_problem_attempts)

        for i in expected_ib_pset_problem_attempts:
            assert i in results

    with open(tmp_path / "ib_input_submissions.csv", 'r') as f:
        results = list(csv.DictReader(f))
        assert len(results) == len(expected_ib_input_submissions)
        for i in expected_ib_input_submissions:
            assert i in results


def test_generate_grade_df_nodata():
    """generate_grade_df should return an empty dataframe when there no courses
    have students entrolled yet
    """
    grade_dict = {
        1: {
            'usergrades': []
        }
    }

    res = data_collection.generate_grade_df(grade_dict)
    expected_columns = [
        'user_id',
        'grade_percentage',
        'assessment_name',
        'course_id',
        'time_submitted'
    ]

    assert all(column in res.columns for column in expected_columns)


def test_generate_attempts_summary_df_nodata():
    """generate_attempts_summary_df should return an empty dataframe when no
    quiz attempts have been made yet
    """
    grade_dict = {
        1: {
            'attempts': {}
        }
    }

    res = data_collection.generate_attempts_summary_df(grade_dict)
    expected_columns = [
        'course_id',
        'user_id',
        'quiz_id',
        'attempt_id',
        'attempt_number',
        'time_started',
        'time_finished',
        'attempt_grade'
    ]

    assert all(column in res.columns for column in expected_columns)


def test_generate_attempt_multichoice_response_df_nodata():
    """generate_attempt_multichoice_response_df should return an empty
    dataframe when no quiz attempts have been made yet
    """

    grade_dict = {
        1: {
            'attempts': {}
        }
    }

    res = data_collection.generate_attempt_multichoice_response_df(grade_dict)
    expected_columns = [
        'course_id',
        'user_id',
        'quiz_id',
        'attempt_id',
        'attempt_number',
        'answer',
        'question_number'
    ]

    assert all(column in res.columns for column in expected_columns)
